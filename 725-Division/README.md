# 725-Division

**不重複**的10個數 abcdefghij **(包含0)** 組成5位數除法 abcde / fghij = x

input x 試求出所有結果
ex: 
	
	79546 / 01283 = 62
	
	94736 / 01528 = 62



**KEY: 如何找出重複的數**

最直觀的方法是利用巢狀迴圈一個一個檢查，但時間複雜度會到達O(N^2)

```C++
for(int i = 0; i <= n.length() ; i++)
{

	for(int j = 0; j <= n.length() ; j++)
	{
		if(n[i] == n[j]) return true ;
	}

}
```
其實有非常多的解法，我這邊使用雜湊表去解決時間複雜度過高的問題，但這樣又會衍生空間複雜度的問題

網路上也有很多種作法，就看自己偏好哪種吧

```C++
bool repeat(int x)
{ // use hash
    int n[10] = { 0,0,0,0,0,0,0,0,0,0 }; // 整數的雜湊表 代表著每個位數出現過的次數
    while(x > 0)
    {
        if (n[x % 10] == 1) return true; // 如果n[最後一個位數]出現過了就回傳有重複
        n[x % 10] = 1; //如果沒有出現過就把出現次數改成1
        x = x / 10 ; //把最後一個位數拿掉(c++的除法預設為無條件捨去)
    }
    return false;
}

```

這樣時間複雜度就會是O(N)
